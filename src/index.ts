import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

// Load environment variables FIRST before any other imports that use them
dotenv.config();

// Production imports
import { env, features, initializeEnvironment } from './config/environment';

// Initialize environment configuration after dotenv is loaded
initializeEnvironment();
import { logger } from './utils/logger';
import { monitoring, monitoringMiddleware } from './utils/monitoring';
import { 
  securityHeaders, 
  requestLogging, 
  errorHandler,
  healthCheckBypass,
  authRateLimit,
  apiRateLimit
} from './middleware/security';
import healthRoutes from './routes/health';
import { testConnection, initializeDatabase, pool } from './database/connection';
import { GmailService } from './services/gmail';
import { EmailModel } from './models/Email';
import { AIService } from './services/ai';
import { DraftModel } from './models/Draft';
import { ContextService } from './services/context';
import { ContextModel } from './models/Context';
import { ResponseService } from './services/response';
import { LearningService } from './services/learning';
import { CalendarService } from './services/calendar';
import { CalendarModel } from './models/Calendar';
import { MeetingDetectionService } from './services/meetingDetection';
import { AutoSchedulingService } from './services/autoScheduling';
import { MeetingPipelineService } from './services/meetingPipeline';
import { MeetingConfirmationService } from './services/meetingConfirmation';
import { AutoGeneratedDraftModel } from './models/AutoGeneratedDraft';
import { PromotionalEmailModel } from './models/PromotionalEmail';
import { TokenStorageService } from './services/tokenStorage';
import { IntelligentEmailRouter } from './services/intelligentEmailRouter';
import { WebhookRenewalService } from './services/webhookRenewal';
import { WebhookTestingSuite } from './services/webhookTesting';
import { google } from 'googleapis';
import { authMiddleware, getUserId } from './middleware/auth';
import authRoutes from './routes/auth';

// ğŸ†• NEW: Import our refactored services
import { ServiceBootstrap } from './core/serviceBootstrap';
import emailRoutes from './routes/emails';
import draftRoutes from './routes/drafts';
import calendarRoutes from './routes/calendar';
import meetingRoutes from './routes/meetings';
import aiRoutes from './routes/ai';
import learningRoutes from './routes/learning';
import autoDraftRoutes from './routes/auto-drafts';
// Phase 3 routes
import webhookRoutes from './routes/webhooks';
import adminRoutes from './routes/admin';
import debugRoutes from './routes/debug';

const app = express();
const port = env.PORT;

// Production middleware - order matters!
app.use(requestLogging);
app.use(healthCheckBypass);
app.use(monitoringMiddleware());
app.use(express.json({ limit: '10mb' }));

// Enable CORS for frontend (conditionally)
if (features.enableCORS) {
  app.use(cors({
    origin: env.NODE_ENV === 'development' 
      ? 'http://localhost:5173' 
      : 'https://chief-phi.vercel.app',
    credentials: true
  }));
}

// Global instances
let gmailService: GmailService;
let emailModel: EmailModel;
let aiService: AIService;
let draftModel: DraftModel;
let contextService: ContextService;
let contextModel: ContextModel;
let responseService: ResponseService;
let learningService: LearningService;
let calendarService: CalendarService;
let calendarModel: CalendarModel;
let meetingDetectionService: MeetingDetectionService;
let autoSchedulingService: AutoSchedulingService;
let meetingPipelineService: MeetingPipelineService;
let meetingConfirmationService: MeetingConfirmationService;
let autoGeneratedDraftModel: AutoGeneratedDraftModel;
let promotionalEmailModel: PromotionalEmailModel;
let tokenStorageService: TokenStorageService;
let intelligentEmailRouter: IntelligentEmailRouter;
let webhookRenewalService: WebhookRenewalService;
let webhookTestingSuite: WebhookTestingSuite;

// Initialize services
async function initializeServices() {
  logger.info('ğŸš€ Initializing Chief AI Email Assistant', {
    environment: env.NODE_ENV,
    port: env.PORT,
    version: '0.1.0'
  });

  // ğŸ†• NEW: Initialize refactored service container (parallel to existing)
  const serviceBootstrap = new ServiceBootstrap();
  await serviceBootstrap.initializeServices();
  console.log('âœ… [REFACTOR] New service container initialized');
  
  // Test database connection
  const dbConnected = await testConnection();
  if (!dbConnected) {
    logger.error('âŒ Cannot connect to database. Please check your DATABASE_URL configuration');
    process.exit(1);
  }

  // Initialize database schema
  await initializeDatabase();

  // Initialize services
  gmailService = new GmailService();
  emailModel = new EmailModel();
  aiService = new AIService();
  draftModel = new DraftModel();
  contextService = new ContextService();
  contextModel = new ContextModel();
  responseService = new ResponseService(aiService, contextService, gmailService);
  learningService = new LearningService(aiService);
  calendarService = new CalendarService();
  calendarModel = new CalendarModel();
  meetingDetectionService = new MeetingDetectionService();
  autoSchedulingService = new AutoSchedulingService();
  meetingPipelineService = new MeetingPipelineService();
  meetingConfirmationService = new MeetingConfirmationService();
  autoGeneratedDraftModel = new AutoGeneratedDraftModel();
  promotionalEmailModel = new PromotionalEmailModel();
  tokenStorageService = new TokenStorageService();
  intelligentEmailRouter = new IntelligentEmailRouter(responseService);
  webhookRenewalService = new WebhookRenewalService();
  webhookTestingSuite = new WebhookTestingSuite();

  logger.info('âœ… All services initialized successfully');
  
  // Start webhook renewal service
  webhookRenewalService.startRenewalService();
}

// Health check routes (no auth required)
app.use('/', healthRoutes);

// Auth routes with rate limiting
app.use('/api/auth', authRateLimit, authRoutes);

// ğŸ†• NEW: Refactored routes (running in parallel with existing routes for testing)
console.log('ğŸ”— [REFACTOR] Registering new route endpoints...');
app.use('/api/v2/emails', emailRoutes);
app.use('/api/v2/drafts', draftRoutes);
app.use('/api/v2/calendar', calendarRoutes);
app.use('/api/v2/meetings', meetingRoutes);
app.use('/api/v2/ai', aiRoutes);
app.use('/api/v2/learning', learningRoutes);
app.use('/api/v2/auto-drafts', autoDraftRoutes);

// ğŸš€ PHASE 3: Infrastructure routes
console.log('ğŸ”— [PHASE 3] Registering infrastructure routes...');
app.use('/api/v2/webhooks', webhookRoutes);
app.use('/api/v2/admin', adminRoutes);
app.use('/api/v2/debug', debugRoutes);

// Import and use misc routes
import miscRoutes from './routes/misc';
app.use('/api/v2/misc', miscRoutes);
console.log('âœ… [PHASE 3] Infrastructure routes registered successfully');

console.log('âœ… [REFACTOR] All new routes registered successfully');

// OAuth routes (separate from API auth routes)
app.get('/auth', (req, res) => {
  const authUrl = gmailService.getAuthUrl();
  console.log('ğŸ” Visit this URL to authorize the app:');
  console.log(authUrl);
  res.json({ authUrl });
});

// Intent-based auth endpoints for proper sign up/sign in flow
app.get('/auth/signup', (req, res) => {
  const authUrl = gmailService.getAuthUrl('signup');
  console.log('ğŸ†• Sign up flow initiated');
  res.json({ authUrl, intent: 'signup' });
});

app.get('/auth/signin', (req, res) => {
  const authUrl = gmailService.getAuthUrl('signin');
  console.log('ğŸ” Sign in flow initiated');
  res.json({ authUrl, intent: 'signin' });
});

app.get('/auth/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    if (!code) {
      // Redirect to frontend with error
      return res.redirect(`http://localhost:5173/auth/callback?error=no_code`);
    }

    // Extract intent from state parameter
    let intent = null;
    if (state) {
      try {
        const stateData = JSON.parse(state as string);
        intent = stateData.intent;
        console.log(`ğŸ¯ OAuth callback with intent: ${intent}`);
      } catch (error) {
        console.log('âš ï¸ Could not parse state parameter, continuing without intent');
      }
    }

    const tokens = await gmailService.setTokens(code as string);
    console.log('âœ… Authorization successful!');
    
    // Get user Gmail address and validate intent
    try {
      const gmail = google.gmail({ version: 'v1', auth: gmailService.oauth2Client });
      const userProfile = await gmail.users.getProfile({ userId: 'me' });
      const gmailAddress = userProfile.data.emailAddress;
      
      if (gmailAddress && tokens.refresh_token) {
        // ğŸ” INTENT VALIDATION - Check user existence vs intent
        const existingUser = await tokenStorageService.getUserByEmail(gmailAddress);
        
        if (intent === 'signin' && !existingUser) {
          console.log(`âŒ Sign in failed: User ${gmailAddress} does not exist`);
          return res.redirect(`http://localhost:5173/auth/callback?error=user_not_found&email=${encodeURIComponent(gmailAddress)}`);
        }
        
        if (intent === 'signup' && existingUser) {
          console.log(`âŒ Sign up failed: User ${gmailAddress} already exists`);
          return res.redirect(`http://localhost:5173/auth/callback?error=user_exists&email=${encodeURIComponent(gmailAddress)}`);
        }
        
        console.log(`âœ… Intent validation passed for ${intent || 'no-intent'}: ${gmailAddress}`);
        
        // Determine if this is a new user (for onboarding flow)
        const isNewUser = !existingUser;
        // Save tokens to database for persistent 24/7 access
        const userId = await tokenStorageService.saveUserTokens(gmailAddress, {
          accessToken: tokens.access_token || '',
          refreshToken: tokens.refresh_token,
          expiresAt: new Date(Date.now() + 3600 * 1000) // 1 hour
        });
        
        console.log(`ğŸ’¾ Tokens saved to database for 24/7 operation. User ID: ${userId}`);
        console.log(`ğŸ“§ Gmail address: ${gmailAddress}`);
        
        // ğŸš€ AUTOMATIC WEBHOOK SETUP - Set up Gmail webhook for real-time processing
        try {
          console.log(`ğŸ”” Setting up automatic webhook subscription for ${gmailAddress}...`);
          
          // Initialize Gmail service for the new user
          await gmailService.initializeForUser(userId);
          
          // Set up webhook subscription
          const watchResponse = await gmailService.setupWebhook();
          
          console.log(`âœ… Automatic webhook setup successful for ${gmailAddress}`);
          console.log(`ğŸ“Š Webhook expires: ${new Date(parseInt(watchResponse.expiration)).toISOString()}`);
        } catch (webhookError) {
          console.error(`âš ï¸ Failed to set up automatic webhook for ${gmailAddress}:`, webhookError);
          // Don't fail the entire OAuth process if webhook setup fails
          // User can still use the system, just without real-time processing
        }
        
        // Generate JWT token for frontend authentication
        const jwtToken = authMiddleware.generateToken(userId, gmailAddress);
        
        // Return JWT token with onboarding status
        const authData = Buffer.from(JSON.stringify({
          jwt_token: jwtToken,
          user_id: userId,
          email: gmailAddress,
          is_new_user: isNewUser,
          needs_onboarding: isNewUser || !existingUser?.onboardingCompleted
        })).toString('base64');
        
        // Redirect to frontend with JWT token and onboarding info
        res.redirect(`http://localhost:5173/auth/callback?success=true&tokens=${encodeURIComponent(authData)}`);
      } else {
        throw new Error('Missing Gmail address or refresh token');
      }
    } catch (error) {
      console.error('âš ï¸ Failed to complete user setup:', error);
      res.redirect(`http://localhost:5173/auth/callback?error=auth_failed`);
    }
  } catch (error) {
    console.error('âŒ Authorization failed:', error);
    // Redirect to frontend with error
    res.redirect(`http://localhost:5173/auth/callback?error=auth_failed`);
  }
});

// Testing endpoint to set tokens directly
app.post('/auth/set-tokens', async (req, res) => {
  try {
    const { accessToken, refreshToken } = req.body;
    if (!accessToken || !refreshToken) {
      return res.status(400).json({ error: 'Both accessToken and refreshToken are required' });
    }
    
    await gmailService.setStoredTokens(accessToken, refreshToken);
    console.log('âœ… OAuth tokens set successfully');
    res.json({ message: 'Tokens set successfully for testing' });
  } catch (error) {
    console.error('âŒ Error setting tokens:', error);
    res.status(500).json({ error: 'Failed to set tokens' });
  }
});

// ğŸ”§ LEGACY WEBHOOK COMPATIBILITY
// Gmail webhooks were configured with the old route - redirect to new V2 route
app.post('/webhooks/gmail', (req, res) => {
  console.log('ğŸ”„ [LEGACY] Gmail webhook received on old route, forwarding to V2...');
  // Forward the request to the new V2 route
  req.url = '/api/v2/webhooks/gmail';
  app._router.handle(req, res);
});

// ====================================
// ğŸš€ REFACTORED ROUTES (V2 STRUCTURE)
// ====================================
// All routes have been migrated to organized v2 structure
// See /docs/API_MIGRATION_GUIDE.md for complete mapping
// Old monolithic routes removed - use /api/v2/* endpoints instead

// ğŸ”§ LEGACY ROUTES MAINTAINED FOR BACKWARD COMPATIBILITY
// Basic health endpoint (always available)
app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    service: 'Chief AI Email Assistant',
    version: '2.0.0',
    migration: 'Routes moved to /api/v2/* structure'
  });
});

// CLI testing function
export async function testPhase1() {
  console.log('\nğŸ§ª PHASE 1 TEST: Email Reading & Parsing\n');

  try {
    await initializeServices();

    console.log('ğŸ“Š Current email stats:');
    const stats = await emailModel.getEmailStats();
    console.log('Total emails:', stats.total);
    console.log('Unread emails:', stats.unread);

  } catch (error) {
    console.error('âŒ Phase 1 test failed:', error);
  }
}

// Graceful shutdown handlers
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  process.exit(0);
});

// Start server
if (require.main === module) {
  // Check if running as test
  if (process.argv[2] === 'test') {
    testPhase1().then(() => process.exit(0));
  } else {
    // Production server start
    initializeServices().then(() => {
      app.listen(port, () => {
        logger.info(`ğŸŒ Chief AI server running on http://localhost:${port}`, {
          environment: env.NODE_ENV,
          port,
          logLevel: env.LOG_LEVEL
        });
        logger.info('ğŸ”§ Server ready and accepting connections');

        if (env.NODE_ENV === 'development') {
          console.log('\nğŸ“‹ Available V2 API endpoints:');
          console.log('   ğŸ” Authentication: /auth/* (unchanged)');
          console.log('   ğŸ“§ Emails: /api/v2/emails/*');
          console.log('   ğŸ“ Drafts: /api/v2/drafts/* & /api/v2/auto-drafts/*');
          console.log('   ğŸ¤– AI Analysis: /api/v2/ai/*');
          console.log('   ğŸ“… Calendar: /api/v2/calendar/*');
          console.log('   ğŸ¤ Meetings: /api/v2/meetings/*');
          console.log('   ğŸ“ Learning: /api/v2/learning/*');
          console.log('   ğŸ“¡ Webhooks: /api/v2/webhooks/*');
          console.log('   ğŸ”§ Admin: /api/v2/admin/*');
          console.log('   ğŸ” Debug: /api/v2/debug/*');
          console.log('   âš¡ Misc: /api/v2/misc/*');
          console.log('\nğŸ“– Migration Guide: /docs/API_MIGRATION_GUIDE.md');
          console.log('ğŸ¯ All legacy routes migrated to organized v2 structure!');
        }
      });
    })
    .catch((error) => {
      console.error('âŒ Failed to start server:', error);
      process.exit(1);
    });
  }
}