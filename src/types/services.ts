/**
 * Service Interface Definitions
 * Provides proper typing for services retrieved from ServiceContainer
 */

// Core service interfaces
export interface GmailServiceInterface {
  initializeForUser(userId: string): Promise<void>;
  getRecentEmails(count: number): Promise<any[]>;
  getSentEmails(count: number): Promise<any[]>;
  getSentEmailsForUser(userId: string, count: number): Promise<any[]>;
  filterSentEmailsForToneAnalysis(emails: any[]): any[];
  parseEmail(email: any): any;
  sendEmail(email: any): Promise<any>;
  getEmailByMessageId(messageId: string): Promise<any>;
  setupWebhook(): Promise<any>;
  getWebhookStatus(): Promise<any>;
  stopWebhook(): Promise<void>;
}

export interface EmailModelInterface {
  getRecentEmails(count: number, userId?: string): Promise<any[]>;
  getEmailStats(userId: string): Promise<any>;
  emailExists(emailId: string, userId: string): Promise<boolean>;
  saveEmail(email: any, userId: string): Promise<number>;
  updateEmailCategory(emailId: number, category: string): Promise<void>;
  getEmailByGmailId(gmailId: string, userId: string): Promise<any>;
  saveEmailAndMarkAsWebhookProcessedForUser(email: any, userId: string): Promise<{ success: boolean; emailId?: number }>;
}

export interface DraftModelInterface {
  getToneProfileHistory(count: number): Promise<any[]>;
  saveToneProfile(profile: any): Promise<number>;
  getLatestToneProfile(): Promise<any>;
  getLatestRealToneProfile(): Promise<any>;
  getPendingDrafts(count: number): Promise<any[]>;
  saveDraft(draft: any): Promise<number>;
}

export interface AIServiceInterface {
  analyzeToneFromRealEmails(emails: any[]): Promise<any>;
  analyzeToneFromEmails(emails: any[]): Promise<string>;
  categorizeEmail(subject: string, body: string, fromEmail: string): Promise<string>;
  generateDraft(email: any, category: string, toneProfile: string): Promise<any>;
  scoreDraft(draftBody: string, originalBody: string, category: string): Promise<number>;
  classifyEmail(subject: string, body: string, fromEmail: string): Promise<string>;
}

export interface CalendarServiceInterface {
  setStoredTokens(accessToken: string, refreshToken: string, expiryDate?: string): Promise<void>;
  getCalendarEvents(startDate: string, endDate: string, maxResults: number): Promise<any[]>;
  checkAvailability(start: string, end: string): Promise<any>;
  suggestTimeSlots(duration: number, date: string, workingHours: any, maxSuggestions: number): Promise<any[]>;
  createCalendarEvent(event: any): Promise<any>;
  checkCalendarHealth(): Promise<any>;
}

export interface WebhookProcessorInterface {
  processGmailNotificationMultiUser(notification: any): Promise<void>;
}

export interface CalendarModelInterface {
  saveCalendarEvent(event: any): Promise<void>;
  getUserPreferences(): Promise<any[]>;
  updateUserPreference(type: string, value: string): Promise<void>;
  getCalendarStats(): Promise<any>;
  calendarHealthCheck(): Promise<any>;
}

export interface TokenStorageServiceInterface {
  getDecryptedCredentials(userId: string): Promise<any>;
  getActiveWebhookUsers(): Promise<any[]>;
  disableWebhookForUser(userId: string, reason: string): Promise<void>;
  getUserIdByEmail(email: string): Promise<string | null>;
  getUserTokens(userId: string): Promise<any>;
}

export interface PromotionalEmailModelInterface {
  getPromotionalEmailsForUser(limit: number, userId: string): Promise<any[]>;
  getPromotionalEmailStatsForUser(userId: string): Promise<any>;
  markAsReadForUser(emailId: number, userId: string): Promise<boolean>;
  deletePromotionalEmailForUser(emailId: number, userId: string): Promise<boolean>;
  savePromotionalEmail(emailData: any): Promise<void>;
}

export interface IntelligentEmailRouterInterface {
  routeEmail(email: any, userId: string, emailDbId?: number): Promise<any>;
}

export interface AutoGeneratedDraftModelInterface {
  getPendingDraftsWithEmails(limit: number, userId: string): Promise<any[]>;
  getDraftById(draftId: number): Promise<any>;
}

export interface ContextServiceInterface {
  analyzeEmailContext(request: any): Promise<any>;
  analyzeSender(email: any): Promise<any>;
  analyzeThreadContext(emails: any[]): Promise<any>;
  extractEntities(email: any): Promise<any[]>;
}

export interface ContextModelInterface {
  getEmailsNeedingContextAnalysis(limit: number): Promise<any[]>;
  getContextStats(): Promise<any>;
  getThreadAnalytics(): Promise<any[]>;
  getSenderInsights(): Promise<any[]>;
  getEntityInsights(): Promise<any[]>;
  getThreadFullContext(threadId: string): Promise<any>;
  contextHealthCheck(): Promise<any>;
  markEmailContextAnalyzed(emailId: number): Promise<void>;
  getThreadAnalysis(limit: number, withSummary: boolean): Promise<any[]>;
  getSenderAnalysis(limit: number, minInteractions: number): Promise<any[]>;
}

export interface ResponseServiceInterface {
  generateSmartResponse(request: any): Promise<any>;
}

export interface LearningServiceInterface {
  analyzeEdit(responseId: string, originalText: string, editedText: string, userId?: string): Promise<any>;
  calculateSuccessMetrics(days: number, detailed: boolean, userId?: string): Promise<any>;
  generateLearningInsights(days: number, userId?: string): Promise<any[]>;
  getPerformanceTrend(days: number, granularity: 'daily' | 'weekly' | 'monthly', userId?: string): Promise<any[]>;
}

export interface MeetingPipelineServiceInterface {
  getMeetingRequests(userId: string, filters: any): Promise<any[]>;
  getMeetingStats(userId: string): Promise<any>;
  healthCheck(): Promise<any>;
}

export interface MeetingDetectionServiceInterface {
  detectMeetingRequest(email: any): Promise<any>;
}

export interface MeetingConfirmationServiceInterface {
  confirmMeeting(meetingId: number): Promise<any>;
  cancelMeeting(meetingId: number, reason?: string): Promise<any>;
}

export interface AutoSchedulingServiceInterface {
  processMeetingRequest(meetingRequestId: number): Promise<any>;
  suggestOptimalTimes(participants: string[], duration: number, preferences?: any): Promise<any>;
  suggestAlternativeTimes(meetingId: number): Promise<any>;
  createCalendarHold(meetingId: number, suggestedTime: any): Promise<any>;
  confirmScheduledMeeting(holdId: number, finalTime: any): Promise<any>;
}

// Service registry type map for better IntelliSense
export interface ServiceRegistry {
  gmailService: GmailServiceInterface;
  emailModel: EmailModelInterface;
  draftModel: DraftModelInterface;
  aiService: AIServiceInterface;
  calendarService: CalendarServiceInterface;
  calendarModel: CalendarModelInterface;
  tokenStorageService: TokenStorageServiceInterface;
  promotionalEmailModel: PromotionalEmailModelInterface;
  intelligentEmailRouter: IntelligentEmailRouterInterface;
  autoGeneratedDraftModel: AutoGeneratedDraftModelInterface;
  contextService: ContextServiceInterface;
  contextModel: ContextModelInterface;
  responseService: ResponseServiceInterface;
  learningService: LearningServiceInterface;
  meetingPipelineService: MeetingPipelineServiceInterface;
  meetingDetectionService: MeetingDetectionServiceInterface;
  meetingConfirmationService: MeetingConfirmationServiceInterface;
  autoSchedulingService: AutoSchedulingServiceInterface;
  webhookProcessor: WebhookProcessorInterface;
  webhookRenewalService: any; // WebhookRenewalService
  webhookTestingSuite: any; // WebhookTestingSuite
  intelligentRouter: any; // For debug routes
  pool: any; // Database pool
}